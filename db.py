#db.py

"""
Database Module for CP Demo Server

This module manages interactions with two SQLite databases:
1. protections.db - Stores protection records.
2. generated_files.db - Stores records of files generated by the application.

Dependencies:
- sqlite3: To interact with SQLite databases.
- csv: To read data from CSV files.
- os: To handle file system operations.
- re: For regular expression operations.
- datetime: To manage date and time.
- logging: To log events for debugging and monitoring.
"""

import sqlite3
import csv
import os
import re
from datetime import datetime
from app import logging
# Paths to the databases
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(BASE_DIR, 'data')

GENERATED_FILES_DIR = os.path.join(DATA_DIR, 'generated_files')  # Corrected path

PROTECTIONS_DB = os.path.join(DATA_DIR, 'protections.db')
FILES_DB = os.path.join(DATA_DIR, 'generated_files.db')

# Ensure the necessary directories exist
os.makedirs(GENERATED_FILES_DIR, exist_ok=True)
os.makedirs(DATA_DIR, exist_ok=True)

# ===========================
# Logging Configuration
# ===========================

# Create a logging object
#logging = logging.getlogging(__name__)

# ===========================
# Database Initialization
# ===========================

def init_db():
    """
    Initialize the protections database by creating the 'protections' table.

    **Warning**: This function drops the existing 'protections' table, which will **delete all existing records**.
    Use with caution to avoid unintended data loss.
    """
    try:
        
        logging.info("Initializing protections database.")
        # Connect to the protections database (creates the file if it doesn't exist)
        conn = sqlite3.connect(PROTECTIONS_DB)
        cursor = conn.cursor()
        
        # Drop the protections table if it exists to ensure a fresh start
        logging.debug("Dropping existing 'protections' table if it exists.")
        cursor.execute('DROP TABLE IF EXISTS protections')
        
        # Create the protections table with specified columns
        logging.debug("Creating 'protections' table.")
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS protections (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ProtectionName TEXT,
            IndustryReference TEXT,
            Method TEXT,
            Resource TEXT,
            Service TEXT,
            ConfidenceLevel TEXT,
            Severity TEXT,
            PerformanceImpact TEXT,
            Agent TEXT
        )
        ''')
        
        # Commit the changes and close the connection
        conn.commit()
        logging.info("'protections' table created successfully.")
    except sqlite3.Error as e:
        logging.error(f"SQLite error during init_db: {e}")
    except Exception as e:
        logging.error(f"Unexpected error during init_db: {e}")
    finally:
        conn.close()
        logging.debug("Database connection closed after init_db.")

def init_db_for_generated_files():
    """
    Initialize the generated_files database by creating the 'generated_files' table.

    **Warning**: This function drops the existing 'generated_files' table, which will **delete all existing records**.
    Use with caution to avoid unintended data loss.
    """
    try:
        logging.info("Initializing generated_files database.")
        # Connect to the generated_files database (creates the file if it doesn't exist)
        conn = sqlite3.connect(FILES_DB)
        cursor = conn.cursor()
        
        # Drop the generated_files table if it exists to ensure a fresh start
        logging.debug("Dropping existing 'generated_files' table if it exists.")
        cursor.execute('DROP TABLE IF EXISTS generated_files')
        
        # Create the generated_files table with specified columns
        logging.debug("Creating 'generated_files' table.")
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS generated_files (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            type TEXT,
            url_type TEXT,
            include_image BOOLEAN,
            include_sensitive_link BOOLEAN,
            include_script BOOLEAN,
            include_video BOOLEAN,
            include_audio BOOLEAN,
            include_3d BOOLEAN,
            include_pdf BOOLEAN,
            include_external_app BOOLEAN,
            include_data_submission BOOLEAN
        )
        ''')
        # Commit the changes and close the connection
        conn.commit()
        logging.info("'generated_files' table created successfully.")
    except sqlite3.Error as e:
        logging.error(f"SQLite error during init_db_for_generated_files: {e}")
    except Exception as e:
        logging.error(f"Unexpected error during init_db_for_generated_files: {e}")
    finally:
        conn.close()
        logging.debug("Database connection closed after init_db_for_generated_files.")

# ===========================
# Data Loading Functions
# ===========================

def load_csv_to_db():
    """
    Load data from a CSV file into the protections database.

    This is intended to be a one-time import operation.

    The CSV should have the following columns:
    - ProtectionName
    - IndustryReference
    - Method
    - Resource
    - Service
    - ConfidenceLevel
    - Severity
    - PerformanceImpact
    - Agent

    Notes:
    - Rows with missing 'ProtectionName' or 'Resource' are skipped.
    - Only rows where 'Service' is "http" are included.
    - IP addresses in the 'Resource' field are detected and replaced with the placeholder "{{IP}}".
    """
    try:
        logging.info("Starting to load CSV data into protections database.")
        ip_pattern = re.compile(r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b')  # Regex for IP address
        
        csv_path = os.path.join(DATA_DIR, 'ips_protections_demo.csv')
        
        if not os.path.exists(csv_path):
            logging.error(f"CSV file not found: {csv_path}")
            return
        
        with open(csv_path, mode='r') as file:
            csv_file = csv.DictReader(file)
            conn = sqlite3.connect(PROTECTIONS_DB)
            cursor = conn.cursor()
        
            for line_number, line in enumerate(csv_file, start=2):  # Start at 2 considering header
                # Skip rows with missing required fields
                if not line.get('ProtectionName') or not line.get('Resource'):
                    logging.warning(f"Skipping row {line_number}: Missing ProtectionName or Resource.")
                    continue
        
                # Only include certain services, e.g., exclude non-HTTP
                if line.get('Service', '').lower() != "http":
                    logging.debug(f"Skipping row {line_number}: Service is not 'http'.")
                    continue
        
                # Detect and replace IP address in the Resource field with {{IP}}
                resource_with_placeholder = ip_pattern.sub("{{IP}}", line['Resource'])
        
                # Insert the processed data into the protections table
                try:
                    cursor.execute('''
                        INSERT INTO protections (ProtectionName, Method, Resource, Agent, IndustryReference, Service, ConfidenceLevel, Severity, PerformanceImpact)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        line['ProtectionName'], 
                        line['Method'], 
                        resource_with_placeholder, 
                        line.get('Agent', ''),
                        line.get('IndustryReference', ''), 
                        line.get('Service', ''),
                        line.get('ConfidenceLevel', ''), 
                        line.get('Severity', ''), 
                        line.get('PerformanceImpact', '')
                    ))
                    logging.debug(f"Inserted row {line_number} into 'protections' table.")
                except sqlite3.Error as e:
                    logging.error(f"SQLite error on row {line_number}: {e}")
                except Exception as e:
                    logging.error(f"Unexpected error on row {line_number}: {e}")
        
            # Commit the transactions and close the connection
            conn.commit()
            logging.info("CSV data loaded successfully into protections database.")
    except Exception as e:
        logging.error(f"Unexpected error during load_csv_to_db: {e}")
    finally:
        try:
            conn.close()
            logging.debug("Database connection closed after load_csv_to_db.")
        except:
            pass  # Connection might have been closed already

# ===========================
# Data Retrieval Functions
# ===========================


def load_csv_to_db():
    """
    Load data from a CSV file into the protections database.

    This is intended to be a one-time import operation.

    The CSV should have the following columns:
    - ProtectionName
    - IndustryReference
    - Method
    - Resource
    - Service
    - ConfidenceLevel
    - Severity
    - PerformanceImpact
    - Agent

    Notes:
    - Rows with missing 'ProtectionName' or 'Resource' are skipped.
    - Only rows where 'Service' is "http" are included.
    - IP addresses in the 'Resource' field are detected and replaced with the placeholder "{{IP}}".
    """
    try:
        logging.info("Starting to load CSV data into protections database.")
        ip_pattern = re.compile(r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b')  # Regex for IP address
        
        csv_path = 'app/data/ips_protections_demo.csv'
        
        if not os.path.exists(csv_path):
            logging.error(f"CSV file not found: {csv_path}")
            return
        
        with open(csv_path, mode='r') as file:
            csv_file = csv.DictReader(file)
            conn = sqlite3.connect('app/data/protections.db')
            cursor = conn.cursor()
        
            for line_number, line in enumerate(csv_file, start=2):  # Start at 2 considering header
                # Skip rows with missing required fields
                if not line.get('ProtectionName') or not line.get('Resource'):
                    logging.warning(f"Skipping row {line_number}: Missing ProtectionName or Resource.")
                    continue
        
                # Only include certain services, e.g., exclude non-HTTP
                if line.get('Service', '').lower() != "http":
                    logging.debug(f"Skipping row {line_number}: Service is not 'http'.")
                    continue
        
                # Detect and replace IP address in the Resource field with {{IP}}
                resource_with_placeholder = ip_pattern.sub("{{IP}}", line['Resource'])
        
                # Insert the processed data into the protections table
                try:
                    cursor.execute('''
                        INSERT INTO protections (ProtectionName, Method, Resource, Agent, IndustryReference, Service, ConfidenceLevel, Severity, PerformanceImpact)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        line['ProtectionName'], 
                        line['Method'], 
                        resource_with_placeholder, 
                        line.get('Agent', ''),
                        line.get('IndustryReference', ''), 
                        line.get('Service', ''),
                        line.get('ConfidenceLevel', ''), 
                        line.get('Severity', ''), 
                        line.get('PerformanceImpact', '')
                    ))
                    logging.debug(f"Inserted row {line_number} into 'protections' table.")
                except sqlite3.Error as e:
                    logging.error(f"SQLite error on row {line_number}: {e}")
                except Exception as e:
                    logging.error(f"Unexpected error on row {line_number}: {e}")
        
            # Commit the transactions and close the connection
            conn.commit()
            logging.info("CSV data loaded successfully into protections database.")
    except Exception as e:
        logging.error(f"Unexpected error during load_csv_to_db: {e}")
    finally:
        try:
            conn.close()
            logging.debug("Database connection closed after load_csv_to_db.")
        except:
            pass  # Connection might have been closed already


# ===========================
# Data Retrieval Functions
# ===========================

def load_protections():
    """
    Retrieve all protection records from the protections database.

    Returns:
        list: A list of tuples, each representing a protection record.
    """
    try:
        logging.info("Loading all protections from the database.")
        conn = sqlite3.connect('app/data/protections.db')
        cursor = conn.cursor()
    
        # Select all relevant columns from the protections table
        cursor.execute('''
            SELECT ProtectionName, IndustryReference, Method, Resource, Service, ConfidenceLevel, Severity, PerformanceImpact, Agent 
            FROM protections
        ''')
    
        # Fetch all rows from the executed query
        data = cursor.fetchall()
        logging.debug(f"Fetched {len(data)} records from 'protections' table.")
    
        conn.close()
        logging.debug("Database connection closed after load_protections.")
    
        return data
    except sqlite3.Error as e:
        logging.error(f"SQLite error during load_protections: {e}")
        return []
    except Exception as e:
        logging.error(f"Unexpected error during load_protections: {e}")
        return []


def get_protection_by_name(protection_name):
    """
    Retrieve a protection's details by its name.

    Args:
        protection_name (str): The name of the protection to retrieve.

    Returns:
        dict or None: A dictionary of protection details if found, else None.
    """
    try:
        logging.info(f"Fetching protection by name: {protection_name}")
        conn = sqlite3.connect('app/data/protections.db')
        cursor = conn.cursor()
    
        # Select all relevant columns for the given protection name
        cursor.execute('''
            SELECT ProtectionName, IndustryReference, Method, Resource, Service, ConfidenceLevel, Severity, PerformanceImpact, Agent
            FROM protections
            WHERE ProtectionName = ?
        ''', (protection_name,))
    
        result = cursor.fetchone()
        conn.close()
        logging.debug(f"Protection fetched: {result}")
    
        if result:
            # Return the result as a dictionary
            protection = {
                'ProtectionName': result[0],
                'IndustryReference': result[1],
                'Method': result[2],
                'Resource': result[3],
                'Service': result[4],
                'ConfidenceLevel': result[5],
                'Severity': result[6],
                'PerformanceImpact': result[7],
                'Agent': result[8]
            }
            logging.info(f"Protection '{protection_name}' retrieved successfully.")
            return protection
        else:
            logging.warning(f"Protection '{protection_name}' not found in the database.")
            return None
    except sqlite3.Error as e:
        logging.error(f"SQLite error during get_protection_by_name: {e}")
        return None
    except Exception as e:
        logging.error(f"Unexpected error during get_protection_by_name: {e}")
        return None


# ===========================
# Generated Files Management
# ===========================

def save_generated_file_to_db(
    filename, file_type, url_type, include_image, include_sensitive_link, 
    include_script, include_video, include_audio, include_3d, 
    include_pdf, include_external_app, include_data_submission):
    """
    Save a generated file's details to the generated_files database.

    Args:
        filename (str): The name of the generated file.
        file_type (str): The type of the file (e.g., 'pdf', 'docx').
        url_type (str): The type of URL embedded ('malicious', 'clean', 'none').
        include_image (bool): Whether the file includes an image.
        include_sensitive_link (bool): Whether the file includes a sensitive link.
        include_script (bool): Whether the file includes a script.
        include_video (bool): Whether the file includes a video.
        include_audio (bool): Whether the file includes audio.
        include_3d (bool): Whether the file includes 3D content.
        include_pdf (bool): Whether the file includes an embedded PDF.
        include_external_app (bool): Whether the file includes an external application link.
        include_data_submission (bool): Whether the file includes data submission features.
    """
    try:
        logging.info(f"Saving generated file to database: {filename}")
        conn = sqlite3.connect(FILES_DB)
        cursor = conn.cursor()
        
        # Insert the generated file details into the generated_files table
        cursor.execute('''INSERT INTO generated_files (
            name, type, url_type, include_image, include_sensitive_link,
            include_script, include_video, include_audio, include_3d,
            include_pdf, include_external_app, include_data_submission
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''', (
            filename, file_type, url_type, include_image, include_sensitive_link,
            include_script, include_video, include_audio, include_3d,
            include_pdf, include_external_app, include_data_submission
        ))
        
        # Commit the transaction and close the connection
        conn.commit()
        logging.info(f"Generated file '{filename}' saved successfully.")
    except sqlite3.Error as e:
        logging.error(f"SQLite error during save_generated_file_to_db: {e}")
    except Exception as e:
        logging.error(f"Unexpected error during save_generated_file_to_db: {e}")
    finally:
        conn.close()
        logging.debug("Database connection closed after save_generated_file_to_db.")


def load_generated_files():
    """
    Retrieve all generated file records from the generated_files database.

    Returns:
        list: A list of dictionaries, each representing a generated file record.
    """
    try:
        logging.info("Loading all generated files from the database.")
        conn = sqlite3.connect(FILES_DB)
        cursor = conn.cursor()
    
        # Select all columns from the generated_files table
        cursor.execute("SELECT * FROM generated_files")
        rows = cursor.fetchall()
    
        # Format the data into a dictionary for easy access
        files = []
        for row in rows:
            files.append({
                'id': row[0],
                'name': row[1],
                'type': row[2],
                'url_type': row[3],
                'include_image': row[4],
                'include_sensitive_link': row[5],
                'include_script': row[6],
                'include_audio': row[7],
                'include_video': row[8],
                'include_3d': row[9],
                'include_pdf': row[10],
                'include_external_app': row[11],
                'include_data_submission': row[12]
            })
        logging.debug(f"Fetched {len(files)} records from 'generated_files' table.")
    
        conn.close()
        logging.debug("Database connection closed after load_generated_files.")
    
        return files
    except sqlite3.Error as e:
        logging.error(f"SQLite error during load_generated_files: {e}")
        return []
    except Exception as e:
        logging.error(f"Unexpected error during load_generated_files: {e}")
        return []


def get_generated_file_by_name(name):
    """
    Retrieve a generated file's details by its name.

    Args:
        name (str): The name of the generated file.

    Returns:
        tuple or None: A tuple containing file details if found, else None.
    """
    try:
        logging.info(f"Fetching generated file by name: {name}")
        print(f"Fetching file details with name: {name}")  # Retaining the original print statement
        conn = sqlite3.connect(FILES_DB)
        cursor = conn.cursor()
    
        # Select all columns for the given file name
        cursor.execute('SELECT * FROM generated_files WHERE name = ?', (name,))
        row = cursor.fetchone()
    
        conn.close()
        logging.debug(f"Generated file fetched: {row}")
    
        return row
    except sqlite3.Error as e:
        logging.error(f"SQLite error during get_generated_file_by_name: {e}")
        return None
    except Exception as e:
        logging.error(f"Unexpected error during get_generated_file_by_name: {e}")
        return None


# ===========================
# File Deletion Functions
# ===========================

def delete_generated_file(filename):
    """
    Delete a generated file from both the database and the filesystem.

    Args:
        filename (str): The name of the file to delete.
    """
    try:
        logging.info(f"Attempting to delete generated file: {filename}")
        conn = sqlite3.connect(FILES_DB)  # Connect to the generated_files database
        cursor = conn.cursor()
    
        # Delete the file record from the database
        cursor.execute("DELETE FROM generated_files WHERE name = ?", (filename,))
        conn.commit()
        logging.info(f"File '{filename}' deleted from database.")
    except sqlite3.Error as e:
        logging.error(f"SQLite error during delete_generated_file: {e}")
    except Exception as e:
        logging.error(f"Unexpected error during delete_generated_file: {e}")
    finally:
        conn.close()
        logging.debug("Database connection closed after delete_generated_file.")
    
    # Delete the file from the filesystem
    file_path = os.path.join(GENERATED_FILES_DIR, filename)  # Path to the file
    try:
        if os.path.exists(file_path):
            os.remove(file_path)
            logging.info(f"File '{filename}' deleted from filesystem.")
        else:
            logging.warning(f"File '{filename}' not found in filesystem.")
    except Exception as e:
        logging.error(f"Error deleting file '{filename}' from filesystem: {e}")


def delete_all_generated_files():
    """
    Delete all generated files from both the database and the filesystem.
    """
    try:
        logging.info("Attempting to delete all generated files.")
        conn = sqlite3.connect(FILES_DB)  # Connect to the generated_files database
        cursor = conn.cursor()
    
        # Delete all records from the generated_files table
        cursor.execute("DELETE FROM generated_files")
        conn.commit()
        logging.info("All files deleted from database.")
    except sqlite3.Error as e:
        logging.error(f"SQLite error during delete_all_generated_files: {e}")
    except Exception as e:
        logging.error(f"Unexpected error during delete_all_generated_files: {e}")
    finally:
        conn.close()
        logging.debug("Database connection closed after delete_all_generated_files.")
    
    # Delete all files from the filesystem
  # Path to the file storage
    try:
        for filename in os.listdir(GENERATED_FILES_DIR):
            file_path = os.path.join(GENERATED_FILES_DIR, filename)
            if os.path.isfile(file_path):
                os.remove(file_path)
                logging.info(f"File '{filename}' deleted from filesystem.")
            else:
                logging.warning(f"File '{filename}' is not a regular file and was skipped.")
    except FileNotFoundError:
        logging.warning(f"File folder not found: {GENERATED_FILES_DIR}")
    except Exception as e:
        logging.error(f"Error deleting files from filesystem: {e}")


